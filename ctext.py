from __future__ import division
from __future__ import print_function
import codecs
import sys
import os
import locale
import tabulate
import time
import pprint as ppr
from oncepy import ccheck
from oncepy import oconfig as cfg
from numpy import *
import numpy.linalg as LA
from sympy import *
from sympy import var as varsym
from sympy import printing
try:
    from PIL import Image as PImage
    from PIL import ImageOps as PImageOps
except:
    pass

mpathctext = os.getcwd()
try:
    from unitc import *
    cfg.unitfile = 'model folder'
except ImportError:
    try:
        os.chdir(os.pardir)
        from unitc import *
        cfg.unitfile = 'project folder'
    except ImportError:
        from oncepy.unitc import *
        cfg.unitfile = 'built-in'
os.chdir(mpathctext)
locale.setlocale(locale.LC_ALL, '')

__version__ = "0.4.6"
__author__ = 'rholland'

class CalcUTF(object):
    """Return UTF-8 calcs
    ::

     Arguments:
        odict (ordered dict) : clean model dictionary
        calcf (str): UTF-8 calc file name
        pyf   (str): Python model name
        sumf  (str): calc summary for database
        filedict (ordered dict) : file op dictionary

        Keys for equations and terms are the dependent
        variable. Keys for other operations are generated by a
        line counter.

        For non-equation entries the dictionary key is:
        _i + incremented number - file operation
        _s + incremented number - sections
        _y + incremented number - symbolic representation
        _t + incremented number - inserted text
        _c + incremented number - check operation
        _a + incremented number - array and ranges
        _f + incremented number - function
        _x + incremented number - pass-through text
        _m + incremented number - current model directory
        _pd - license text

     The dictionary structure is:

     single line inputs:
        file:     [[i], refnum, description, mod number]
        sections: [[s], left string, notes]
        symbolic: [[y], expr]
        terms:    [[t], statement, expr, ref ]

     internal:
        blank line: [~]
        text:       [[x], text]
        read data   [[rd], var = data]

     multiline inputs
        check:    [[c], check expr, limits, ref, ok]
        arrays:   [[a], state1, expr, range1, range2, ref, dec, u1, u2]
        function: [[f], function call, var, ref, eq num]
        equations:[[e], statement, expr, ref, decimals, units, prnt opt]

    """

    def __init__(self, odict1, filedict1, calcf, pyf, sumf):
        """Initialize parameters for UTF calc.
        ::

         Arguments:
            odict1 (dictionary):  model dictionary; array and file ops added
            filedict1 (dctionary): file operation dictionary
            calcf (string): calc file name
            pyf (string): python file name
            sumf (string): summary file name
        """
        # dicts
        self.ew = ccheck.ModCheck()
        self.odict = odict1
        self.fidict = filedict1
        self.symb = self.odict.keys()

        # paths
        self.mpath = cfg.mpath
        self.mfile = cfg.mfile
        self.cfile = codecs.open(calcf, 'w', encoding='utf8')

        # parameters
        self.pyfile = pyf
        self.sumfile = sumf
        self.fignum = 0
        self.widthc = 90
        self.xtraline = False

        # print date at top of calc
        self._prt_utf(time.strftime("%c")+
            "     onceutf version: " + __version__, 0)

        # add array variables (not range variables) to model dictionary key
        for k1 in self.odict:
            if k1[0:2] == '_a':
                try:
                    varkey = self.odict[k1][1].split('=')[0].strip()
                    self.odict[varkey] = ['[a1]', self.odict[k1][1],'','','',
                                          '','','','']
                except:
                    pass

    def gen_utf(self):
        """Generate utf calc from model dictionary.

        """

        for _i in self.odict:
            mtag = self.odict[_i][0]
            #print('rmtag', mtag, _i, self.odict[_i])

            if self.odict[_i][1].strip() == '#stop':
                sys.exit(1)

            if mtag ==   '[i]':
                self._prt_file(self.odict[_i])
                self.xtraline = True
            elif mtag == '[s]':
                self._prt_sect(self.odict[_i])
                self.xtraline = False
            elif mtag == '[y]':
                self._prt_sym(self.odict[_i])
                self.xtraline = False
            elif mtag == '[t]':
                self._prt_term(self.odict[_i])
                self.xtraline = True
            elif mtag == '[c]':
                self._prt_check(self.odict[_i])
                self.xtraline = True
            elif mtag == '[a]':
                self._prt_array(self.odict[_i])
                self.xtraline = True
            elif mtag == '[f]':
                self._prt_func(self.odict[_i])
                self.xtraline = True
            elif mtag == '[e]':
                self._prt_eq(self.odict[_i])
                self.xtraline = False
            elif mtag == '[x]':
                self._prt_txt(self.odict[_i])
                self.xtraline = True
            else:
                pass

            if mtag == '[~]' and self.xtraline is False:
                self.xtraline = True
            if mtag == '[~]' and self.xtraline is True:
                self._prt_blnk()

        for i2 in self.odict:               # add calc license
            if i2 == '_pd':
                self._prt_utf(self.odict[i2],0)

        self._prt_utf('\n[end of calc]', 0) # end calc
        self.cfile.close()                  # close calc file
        self._prt_py()                      # print ipython file
        self._prt_summary()                 # print calc summary file
        #for _i in self.odict: print(i, self.odict[i])

    def get_odict(self):
        return self.odict

    def _prt_sect(self, dval):
        """Print sections to UTF-8.
        ::

         arguments:
            dval (dictionary value): ['[s]', sleft, file number]

        """
        self._prt_utf('='*self.widthc, 0)
        self._prt_utf(dval[1] + dval[2].rjust(self.widthc - len(dval[1])-1), 1)
        self._prt_utf('='*self.widthc, 0)

    def _prt_sym(self, dval):
        """print symbolic expression

        Dictionary:
        _y : [[y], symlang, expr, eqnumber]

        """
        sf1 = 1.33
        pr1 = "\\documentclass[preview, 12pt]{standalone}\n" \
                    "\\begin{document}\n"


        if dval[1] == 's' or dval[1] == 'p':
            expr1 = dval[2].replace('=', '<=')
            exp2 = expr1.split('\n')
            exp3 = ' '.join([ix.strip() for ix in exp2])
            symp1 = sympify(exp3)

            for _j in symp1.atoms():
                varsym(str(_j))

            symeq = eval(expr1)
            symeq2 = pretty(symeq, wrap_line=False)
            out3 = symeq2.replace('*', u'\u22C5')
            cnt = 0
            for _m in out3:
                if _m == '-':
                    cnt += 1
                    continue
                else:
                    if cnt > 1:
                        out3 = out3.replace('-'*cnt, u'\u2014'*cnt)
                    cnt = 0
            self._prt_utf(out3.replace('<=', '='), 1)
            self._prt_utf(" ", 0)

            try:
                if dval[1] == 'p':
                    f1 = "latex" + str(dval[3].strip()) + ".png"
                    self._prt_utf("equation <file: " + str(f1) + ">", 0)
                    expr5 = latex(eval(expr1))
                    expr6 = '$'+ expr5.replace('<=', '=') +'$'
                    printing.preview(expr6, output='png', viewer='file',
                                     filename=f1, preamble=pr1)
                    im10 = PImage.open(f1)
                    imwidth, imheight = im10.size
                    im20 = im10.resize((int(imwidth*sf1), int(imheight*sf1)), PImage.BICUBIC)
                    im20 = PImageOps.expand(im20,border=10,fill='white')
                    im20.save(f1, "PNG")
            except:
                self.ew.errwrite("< p option for [y] operation requires LaTeX - "
                             "file not written >", 1)

        if dval[1] == 'x':
            try:
                f1 = "latex" + str(dval[3].strip()) + ".png"
                self._prt_utf("equation <file: " + str(f1) + ">", 0)
                expr6 =  '$' + dval[2].strip() + '$'

                printing.preview(expr6, output='png', viewer='file',
                                 filename=f1, preamble=pr1)
                im10 = PImage.open(f1)
                imwidth, imheight = im10.size
                im20 = im10.resize((int(imwidth*sf1), int(imheight*sf1)), PImage.BICUBIC)
                im20 = PImageOps.expand(im20, border=10, fill='white')
                im20.save(f1, "PNG")
            except:
                self.ew.errwrite("< x option for [y] operation requires LaTeX - "
                               "file not written >", 1)
        self._prt_utf(" ", 0)

    def _prt_term(self, dval):
        """Print terms to UTF-8.
        ::

         arguments:
            dval (dictionary value): ['[t]', statement, expr, ref ]

        """
        val1 = eval(dval[2])
        ptype = type(val1)
        var1 = dval[1].split('=')[0].strip()
        state = var1 + ' = ' + str(val1)
        if ptype == ndarray or ptype == list or ptype == tuple:
            state = var1 + ' = ' + '\n' + str(val1)
        shift = int(self.widthc / 2.5)
        ref = dval[3].strip().ljust(shift)
        if ptype == ndarray or ptype == list or ptype == tuple:
            self._prt_utf(" "*4 + ref + " | " + state,  0)
        else:
            self._prt_utf(" "*4 + ref + " | " + state,  1)

    def _prt_check(self, dval):
        """print checks

        Dictionary:
        check:  [[c], check expr, op, limit, ref, dec, ok]

        """
        try:
            exec("set_printoptions(precision=" + dval[5].strip() + ")")
            exec("Unum.VALUE_FORMAT = '%." + dval[5].strip() + "f'")
        except:
            set_printoptions(precision=3)
            Unum.VALUE_FORMAT = "%.3f"


        # convert variables to symbols
        for _j in self.symb:
            if _j[0] != '_':
                varsym(_j)

        # symbolic form
        symeq1 = eval(dval[1].strip() + dval[2].strip() +
                      dval[3].strip())
        #pprint(symeq1)
        # evaluate variables
        for _k in self.odict:
            if _k[0] != '_':
                #print(self.odict[_k][1].strip())
                exec(self.odict[_k][1].strip())
            if _k[0:2] == '_a':
                #print('array', self.odict[_k][1].strip())
                exec(self.odict[_k][3].strip())
                exec(self.odict[_k][4].strip())
                exec(self.odict[_k][1].strip())
        # substitute values
        try:
            nounits1 = eval(dval[1].strip()).asNumber()
        except:
                nounits1 = eval(dval[1].strip())
        try:
            nounits2 = eval(dval[3].strip()).asNumber()
        except:
                nounits2 = eval(dval[3].strip())

        result = eval(str(nounits1) + dval[2].strip() + str(nounits2))
        resultform = '{:.' + dval[5].strip() + 'f}'
        result1 = resultform.format(float(str(nounits1)))
        result2 = resultform.format(float(str(nounits2)))
        subbed = result1 + ' ' + dval[2].strip() + ' ' + result2

        if result:
            comment = ' ' + dval[6].strip()
        else:
            comment = ' *** not ' + dval[6].strip() + ' ***'

        out2p = subbed + '  ' + comment
        strend = dval[4].strip()
        tmp = int(self.widthc-2) * '-'
        self._prt_utf((u'\u250C' + tmp + u'\u2510').rjust(self.widthc), 0)
        self._prt_utf(strend.rjust(self.widthc), 1)
        self._prt_utf(" ", 0)

        # symbolic representation
        self._prt_utf(pretty(symeq1), 1)

        # print substituted values in equation
        symat = symeq1.atoms(Symbol)

        #rewrite equation - extend variables to length of value
        for _n in symat:
            #get length of eval(variable)
            evlen = len((eval(_n.__str__())).__str__())
            new_var = str(_n).rjust(evlen, '~')
            new_var = new_var.replace('_','|')
            symeq1 = symeq1.subs(_n, symbols(new_var))
        # list of new symbols
        symat1 = symeq1.atoms(Symbol)
        out2 = pretty(symeq1, wrap_line=False)

        #substitute values
        for _n in symat1:
            o_var = str(_n).replace('~', '')
            o_var = o_var.replace('|', '_')
            expr1 = eval((self.odict[o_var][1]).split("=")[1])
            if type(expr1) == float:
                form = '{:.' + dval[5].strip()+'f}'
                symvar1 = form.format(eval(str(expr1)))
            else:
                symvar1 = eval(o_var.__str__()).__str__()
            out2 = out2.replace(str(_n), symvar1)

        # clean up unicode
        out3 = out2.replace('*', u'\u22C5')
        cnt = 0
        for _m in out3:
            if _m == '-':
                cnt += 1
                continue
            else:
                if cnt > 1:
                    out3 = out3.replace('-'*cnt, u'\u2014'*cnt)
                cnt = 0

        # print substituted form
        self._prt_utf(" ", 0)
        self._prt_utf(out3, 1)
        self._prt_utf(" ", 0)

        # result
        self._prt_utf(out2p.rjust(self.widthc-1), 1)
        tmp = int(self.widthc-2) * '-'
        self._prt_utf((u'\u2514' + tmp + u'\u2518').rjust(self.widthc), 0)
        self._prt_utf(" ", 0)

    def _prt_array(self, dval):
        """Print arrays to UTF-8.
        ::

         arguments:
            dval (dictionary values): [[a], statement, expr, range1, range2,
                                    ref, decimals, unit1, unit2]

        """
        try:
            eformat, rformat = dval[6].split(',')
            exec("set_printoptions(precision=" + eformat.strip() + ")")
            exec("Unum.VALUE_FORMAT = '%." + eformat.strip() + "f'")
        except:
            rformat = '3'
            eformat = '3'
            set_printoptions(precision=3)
            Unum.VALUE_FORMAT = "%.3f"

        #print('array dval', dval)
        # table heading
        tmp = int(self.widthc-2) * '-'
        self._prt_utf((u'\u250C' + tmp + u'\u2510').rjust(self.widthc), 0)
        tright = dval[5].strip().split(' ')
        eqnum = tright[-1].strip()
        tleft = ' '.join(tright[:-1]).strip()
        self._prt_utf((tleft + ' ' + eqnum).rjust(self.widthc), 0)
        self._prt_utf(' ', 0)


        # print symbolic form
        # convert variables to symbols
        vect = dval[1:]
        try:
            for _j in self.symb:
                if str(_j)[0] != '_':
                    varsym(str(_j))
            #convert array variable
            var1 = vect[2].split('=')[0].strip()
            varsym(str(var1))
            try:
                var2 = vect[3].split('=')[0].strip()
                varsym(str(var2))
            except:
                pass

            symeq = eval(vect[1].strip())
            out1 = symeq

            etype = vect[0].split('=')[1]
            if etype.strip()[:1] == '[':
                out1 = str(vect[0].split('=')[1])

            self._prt_utf(" ", 0)
            self._prt_utf(out1, 1)
            self._prt_utf(" ", 0)
        except:
            self._prt_utf(vect[0].strip(), 1)
            self._prt_utf(" ", 0)

        # add array variables to odict
        # evaluate equation and array variables - strip units
        for k1 in self.odict:
            if k1[0] != '_' or k1[0:2] == '_a':
                    try:
                        exec(self.odict[k1][3].strip())
                    except:
                        pass
                    try:
                        exec(self.odict[k1][4].strip())
                    except:
                        pass
                    try:
                        exec(self.odict[k1][1].strip())
                    except:
                        pass
                    try:
                        state = self.odict[k1][1].strip()
                        varx = state.split('=')
                        state2 = varx[0].strip()+'='+varx[0].strip() + '.asNumber()'
                        exec(state2)
                        #print('j1', k1)
                    except:
                        pass

        # single row vector - 1D table
        if len(str(vect[3])) == 0 and len(str(vect[0])) != 0:
            # process range variable 1
            rnge1 = vect[2]
            exec(rnge1.strip())
            rnge1a = rnge1.split('=')
            rlist = [vect[6].strip() + ' = ' +
                     str(_r)for _r in eval(rnge1a[1])]

            #process equation
            equa1 = vect[0].strip()
            #print('equa1', equa1)
            exec(equa1)
            var2 = equa1.split('=')[0]
            etype = equa1.split('=')[1]
            elist1 = eval(var2)
            if etype.strip()[:1] == '[':
                # data is in list form
                elist2 = []
                alist1 = eval(equa1.split('=')[1])
                for _v in alist1:
                    try:
                        elist2.append(list(_v))
                    except:
                            elist2.append(_v)
            else:
                try:
                    elist2 = elist1.tolist()
                except:
                    elist2 = elist1

            elist2 = [elist2]
            #print('elist', elist2)
            # create table
            table1 = tabulate
            ptable = table1.tabulate(elist2, rlist, 'rst',
                                floatfmt="."+ eformat +"f")

            self._prt_utf(ptable, 1)
            tmp = int(self.widthc-2) * '-'
            self._prt_utf((u'\u2514' + tmp + u'\u2518').rjust(self.widthc), 0)


        # 2D table
        if len(str(vect[3])) != 0 and len(str(vect[0])) != 0:
            # process range variable 1
            rnge1 = vect[2]
            exec(rnge1.strip())
            rnge1a = rnge1.split('=')
            rlist = [vect[6].strip() + ' = ' +
                     str(_r) for _r in eval(rnge1a[1])]

            # process range variable 2
            rnge2 = vect[3]
            exec(rnge2.strip())
            rnge2a = rnge2.split('=')
            clist = [str(_r).strip() for _r in eval(rnge2a[1])]
            rlist.insert(0, vect[7].strip())

            # process equation
            equa1 = vect[0].strip()
            exec(equa1)
            etype = equa1.split('=')[1]
            if etype.strip()[:1] == '[':
                # data is in list form
                alist = []
                alist1 = eval(equa1.split('=')[1])
                for _v in alist1:
                    for _x in _v:
                        #print('_x', type(_x), _x)
                        alist.append(list(_x))
            else:
                # data is in equation form
                equa1a = vect[0].strip().split('=')
                equa2 = equa1a[1]
                rngx = rnge1a[1]
                rngy = rnge2a[1]
                ascii1 = rnge1a[0].strip()
                ascii2 = rnge2a[0].strip()

                # format table
                alist = []
                for _y12 in eval(rngy):
                    alistr = []
                    for _x12 in eval(rngx):
                        eq2a = equa2.replace(ascii1, str(_x12))
                        eq2b = eq2a.replace(ascii2, str(_y12))
                        el = eval(eq2b)
                        alistr.append(el)
                    alist.append(alistr)

            for _n, _p in enumerate(alist):
                _p.insert(0, clist[_n])

            # create table
            table2 = tabulate
            flt1 = "." + eformat.strip() + "f"
            ptable = table2.tabulate(alist, rlist, 'rst', floatfmt=flt1)
            nstr = pretty(ptable, use_unicode=True, num_columns=92)

            # print table
            self._prt_utf(nstr, 1)
            tmp = int(self.widthc-2) * '-'
            self._prt_utf((u'\u2514' + tmp + u'\u2518').rjust(self.widthc), 0)

    def _prt_func(self, dval):
        """Print functions to UTF-8.
        ::

         arguments:
            dval (dictionary value): [[f], function call, var, ref, eqn number

        """
        # convert symbols to numbers - retain units
        for k1 in self.odict:
            if k1[0] != '_':
                try:
                    exec(self.odict[k1][1].strip())
                except:
                    pass
            if k1[0:2] == '_a':
                #print('ek1-2', k1, self.odict[k1])
                try:
                    exec(self.odict[k1][3].strip())
                    exec(self.odict[k1][4].strip())
                    exec(self.odict[k1][1].strip())
                except:
                    pass
        # print reference line
        tmp = int(self.widthc-2) * '-'
        self._prt_utf((u'\u250C' + tmp + u'\u2510').rjust(self.widthc-1), 0)

        funcdescrip = dval[3].split(']')[1]
        strend = funcdescrip.strip() + ' ' + dval[4].strip()
        self._prt_utf(strend.rjust(self.widthc - 1), 0)

        # evaluate function
        self._prt_utf(" ", 0)
        self._prt_utf('return variable: ' + dval[2].strip(), 0)
        self._prt_utf(" ", 1)
        self._prt_utf('function call: ' + dval[1].strip(), 0)
        funcname = dval[1].split('(')[0]
        docs1 = eval(funcname + '.__doc__')
        self._prt_utf(' ', 0)
        self._prt_utf('function doc:', 0)
        self._prt_utf(docs1, 0)
        self._prt_utf(' ', 0)
        #print(dval[1].strip())
        return1 = eval(dval[1].strip())
        if return1 is None:
            self._prt_utf('function evaluates to None', 0)
        else:
            self._prt_utf('function return: ', 0)
            self._prt_utf(return1, 0)

        # add function variable to dict
        return2 = (return1.__repr__()).replace('\n', '')
        self.odict[dval[2]] = ['[z]', str(dval[2])+'='+return2]
        #print(self.odict[dval[2]])
        tmp = int(self.widthc-2) * '-'
        self._prt_utf((u'\u2514' + tmp + u'\u2518').rjust(self.widthc), 0)
        self._prt_utf(" ", 0)

    def _prt_eq(self, dval):
        """print equations

        Dictionary:
        equations:[[e], statement, expr, ref, decimals, units, prnt opt]

        """
        # set decimal format
        try:
            eformat, rformat = dval[4].split(',')
            exec("set_printoptions(precision=" + eformat.strip() + ")")
            exec("Unum.VALUE_FORMAT = '%." + eformat.strip() + "f'")
        except:
            rformat = '3'
            eformat = '3'
            set_printoptions(precision=3)
            Unum.VALUE_FORMAT = "%.3f"

        cunit = dval[5].strip()
        var3 = dval[1].split("=")[0].strip()

        # evaluate equation and array variables - strip units
        for k1 in self.odict:
            if k1[0] != '_' or k1[0:2] == '_a':
                    try:
                        exec(self.odict[k1][3].strip())
                    except:
                        pass
                    try:
                        exec(self.odict[k1][4].strip())
                    except:
                        pass
                    try:
                        exec(self.odict[k1][1].strip())
                    except:
                        pass

        if dval[6].strip() == '' :
            dval[6] = '3'
        # evaluate only - do not print
        if dval[6].strip() == '0':
            return

        exec(dval[1])

        # symbolic and substituted forms
        if dval[6].strip() == '3' or dval[6] == '2':
            # print reference line
            tmp = int(self.widthc-2) * '-'
            self._prt_utf((u'\u250C' + tmp + u'\u2510').rjust(self.widthc), 1)
            strend = dval[3].strip()
            self._prt_utf((var3 + " | " + strend).rjust(self.widthc-1), 0)
            self._prt_utf(" ", 0)

            # print symbolic form
            for _j in self.symb:
                if str(_j)[0] != '_':
                    varsym(str(_j))
            try:
                symeq = sympify(dval[2].strip())
                self._prt_utf(symeq, 1)
                self._prt_utf(" ", 0)
                self._prt_utf(" ", 0)
            except:
                self._prt_utf(dval[2], 1)
                self._prt_utf(" ", 0)

            # substitute values
            if dval[6].strip() == '3':
                symat = symeq.atoms(Symbol)
                symeq1 = sympify(dval[2].strip())
                #rewrite equation - new variables same length as value
                for _n2 in symat:
                    #get length of eval(variable)
                    evlen = len((eval(_n2.__str__())).__str__())
                    new_var = str(_n2).rjust(evlen, '~')
                    new_var = new_var.replace('_','|')
                    symeq1 = symeq1.subs(_n2, symbols(new_var))
                symat1 = symeq1.atoms(Symbol)
                out2 = pretty(symeq1, wrap_line=False)

                # manage variable substitution
                for _n1 in symat1:
                    orig_var = str(_n1).replace('~', '')
                    orig_var = orig_var.replace('|', '_')
                    try:
                        expr = eval((self.odict[orig_var][1]).split("=")[1])
                        if type(expr) == float:
                            form = '{:.' + eformat +'f}'
                            symeval1 = form.format(eval(str(expr)))
                        else:
                            symeval1 = eval(orig_var.__str__()).__str__()
                    except:
                        symeval1 = eval(orig_var.__str__()).__str__()
                    out2 = out2.replace(_n1.__str__(), symeval1)

                # clean up unicode
                out3 = out2.replace('*', u'\u22C5')
                cnt = 0
                for _m in out3:
                    if _m == '-':
                        cnt += 1
                        continue
                    else:
                        if cnt > 1:
                            out3 = out3.replace('-'*cnt, u'\u2014'*cnt)
                        cnt = 0

                # print substituted form
                self._prt_utf(out3, 1)
                self._prt_utf(" ", 0)

            # print result right justified
            # restore units
            for j2 in self.odict:
                try:
                    state = self.odict[j2][1].strip()
                    exec(state)
                except:
                    pass

        # result
        typev = type(eval(var3))
        if typev == ndarray:
            tmp1 = eval(var3)
            self._prt_utf((var3 + " = "), 1)
            self._prt_utf(' ', 0)
            self._prt_utf(tmp1, 0)
        elif typev == list or typev == tuple:
            tmp1 = eval(var3)
            self._prt_utf((var3 + " = "), 1)
            self._prt_utf(' ', 0)
            plist1 = ppr.pformat(tmp1, width=40)
            self._prt_utf(plist1, 0)
        elif typev == Unum:
            exec("Unum.VALUE_FORMAT = '%." + rformat.strip() + "f'")
            if len(cunit) > 0:
                tmp = eval(var3).asUnit(eval(cunit))
            else:
                tmp = eval(var3)
            tmp1 = tmp.strUnit()
            tmp2 = tmp.asNumber()
            chkunit = str(tmp).split()
            #print('chkunit', tmp, chkunit)
            if len(chkunit) < 2:
                tmp1 = ''
            resultform = "{:,."+rformat + "f}"
            result1 = resultform.format(tmp2)
            tmp3 = result1 + ' '  + tmp1
            self._prt_utf((var3 + " = " + tmp3).rjust(self.widthc-1), 1)
        else:
            if type(eval(var3)) == float or type(eval(var3)) == float64:
                resultform = "{:,."+rformat + "f}"
                result1 = resultform.format(eval(var3))
                self._prt_utf((var3 +"="+ str(result1)).rjust(self.widthc-1), 1)
            else:
                self._prt_utf((var3 +"="+ str(eval(var3))).rjust(self.widthc-1), 1)

        # horizontal line
        tmp = int(self.widthc-2) * '-'
        self._prt_utf((u'\u2514' + tmp + u'\u2518').rjust(self.widthc), 1)
        self._prt_utf(" ", 0)


    def _prt_file(self, refnum1):
        """Process file operations from file dictionary.
        ::

         arguments:
            refnum1 (string): file operation reference number


         file dictionary:
            file op number :[option, file path, var1, var2, var3, modnum]

         options:
            s: run a python script
            t: add text file contents to output
                No operations are processed.
            o: run an external operating system command.
            w: write values of variable to file. w+ appends to file.
            f: insert jpg, png etc, figures into calc
            i: insert and process external model file.
                Integrate sections and equation numbering.
            r: read file data into variable - processed when tagged
            e: edit file. Store edits in var3. (multiline)

         for equation entries the dictionary key is the resultant variable
         for non-equation entries the dictionary key is:
            _x + incremented number - pass-through text
            _y + incremented number - symbolic representation
            _s + incremented number - sections
            _t + incremented number - inserted text
            _p + incremented number - python code
            _c + incremented number - check operation
            _a + incremented number - array and ranges
            _m + incremented number - current model directory
            _i + incremented number - file operation
            _f + incremented number - function
            _pd - license text

        """
        dval = self.fidict[refnum1[1]]
        #print('dval', dval)

        option = dval[0].strip()
        fpath = dval[1].strip()
        fp = os.path.abspath(fpath)
        var1 = dval[2].strip()
        var2 = dval[3].strip()
        var3 = dval[4]  # variable with edit lines

        # relative path specified for the following options
        if option == 's':
            # execute script in model namespace
            with open(fp, 'r') as f1:
                fr = f1.read()
            exec(fr, globals())
            link1 = "< ran python script : " + str(fpath) + " >"
            self.ew.errwrite(link1, 1)
            self.ew.errwrite("file: " + str(fp) + " executed", 0)

        elif option == 't':
             # insert file from text into model, do not process
            with open(fpath, 'r') as f1:
                txstrng = f1.readlines()
            if var1.strip() != '':
                instxt = eval('txstrng[' + var1.strip() + ']')
                instxt = ''.join(instxt)
            else:
                instxt = ''.join(txstrng)

            self._prt_utf(instxt, 0)

            link1 = "< text inserted from file: " + str(fpath) + " >"
            self.ew.errwrite(link1, 1)
            self.ew.errwrite('', 0)

        elif option == 'o':
            # execute operating system command
            os.system(fpath)
            link1 = "< execute command: " + str(fp) + " >"
            self.ew.errwrite(link1, 0)
            self.ew.errwrite('', 0)

        elif option == 'o':
            # execute operating system command
            os.system(fpath)
            link1 = "< execute command: " + str(fp) + " >"
            self.ew.errwrite(link1, 0)
            self.ew.errwrite('', 0)

        elif option == 'w':
            # write data to file, replace if exists
            sep1 = var2
            if sep1 == '':
                sep1 = ','
            elif sep1 == '*':
                sep1 = " "

            format1 = var3
            if format1 == '':
                format1 = '%s'

            file1 = open(fp, 'w')
            var11 = array(var1)
            var11.tofile(file1, sep=sep1, format=format1)
            file1.close()
            link1 = "< write variable " + var1 + " to file: " \
                    + str(fp) + ">"
            self.ew.errwrite(link1, 0)

        elif option == 'w+':
            # append data to file
            sep1 = var2
            if sep1 == '':
                sep1 = ','
            elif sep1 == '*':
                sep1 = " "

            format1 = var3
            if format1 == '':
                format1 = '%s'

            file1 = open(fp, 'a')
            var11 = array(var1)
            var11.tofile(file1, sep=sep1, format=format1)
            file1.close()
            link1 = "< append variable " + var1 + " to file: " \
                    + str(fp) + ">"
            self.ew.errwrite(link1, 0)

        elif option == 'f':
            # insert figure reference in utf-8 document
            self.fignum += 1
            link1 = "< insert figure " + str(self.fignum) + '. ' \
                    + " file: " + str(fpath) + '>'
            self.ew.errwrite(link1, 0)
            link2 = "Figure " + str(self.fignum) + '. ' + var1 \
                    + " <file: " + str(fpath) + " >"
            self._prt_utf(link2, 1)
            self._prt_utf(" ", 0)

        elif option == 'i':
            # this option is handled in ModDicts.__init__
            # comodels are always processed first, regardless of location
            pass

        # absolute path specified for the following options
        elif option == 'r':
            self._prt_read(dval)

        elif option == 'e':
            self._prt_edit(dval)
        else:
            pass

    def _prt_read(self, dval):
        """Read csv data file.
        ::

         arguments:
            dval (dictionary value):
                option = dval[0].strip()
                fpath = dval[1].strip()
                    fp = os.path.abspath(fpath)
                var1 = dval[2].strip() # variable
                var2 = dval[3].strip() # sep character
                var3 = dval[4]  # skip lines
            var4 = data from genfromtext

        """

        option = dval[0].strip()
        fpath = dval[1].strip()
        fp = os.path.abspath(fpath)
        var1 = dval[2].strip()
        var2 = dval[3].strip()
        var3 = dval[4]

        # print reference line
        tmp = int(self.widthc-2) * '-'
        self._prt_utf((u'\u250C' + tmp + u'\u2510').rjust(self.widthc), 0)

        #print('dval', dval)
        strend = var1 + " | read data "
        self._prt_utf(strend.rjust(self.widthc - 1), 0)
        self._prt_utf(" ", 1)

        # set skip lines
        skip1 = dval[4]
        if skip1 == '':
            skip1 = int(0)
        else:
            skip1 = int(skip1)

        fpath = dval[1].strip()
        # set separator
        sep1 = dval[3]
        if sep1 == '*':
            var4 = genfromtxt(fpath, delimiter=' ',
                              skip_header=skip1)
        elif sep1 == ',' or sep1 == '':
            var4 = genfromtxt(fpath, delimiter=',',
                              skip_header=skip1)
        else:
            var4 = genfromtxt(fpath, delimiter=str(sep1),
                              skip_header=skip1)
        #print('var4', var4[:2])

        cmdstr1 = str(dval[2].strip())
        cmdstr2 = cmdstr1 + '=' + str(list(var4))
        exec(cmdstr2)
        self.odict[cmdstr1] = ['[rd]', cmdstr2]
        #print('cmdstr1', cmdstr1, self.odict[cmdstr1])

        # print summary of selected data
        self._prt_utf("file: " + dval[1].strip(), 0)
        self._prt_utf(' ', 0)
        self._prt_utf(str(var4[:4]) + ' ... ' + str(var4[-4:]), 1)
        self._prt_utf(' ', 0)

        tmp = int(self.widthc-2) * '-'
        self._prt_utf((u'\u2514' + tmp + u'\u2518').rjust(self.widthc), 0)
        self._prt_utf(" ", 0)

        #print('mdict', self.mdict[str(var1)])

    def _prt_edit(self, dval):
            """Edit existing file through line replacement.
            ::

             arguments:
                dval (dictionary value):
                    option = dval[0].strip()
                    fpath = dval[1].strip()
                        fp = os.path.abspath(fpath)
                    var1 = dval[2].strip()
                    var2 = dval[3].strip()
                    var3 = dval[4]  # variable with edit lines

            """

            fpath = dval[1].strip()
            fp = os.path.abspath(fpath)
            var1 = dval[2].strip()
            var2 = dval[3].strip()
            var3 = dval[4]  # variable with edit lines

            f1 = open(fpath, 'r')
            oldfile = f1.readlines()
            f1.close()
            # edit file
            for lines in var3:
                #print(lines)
                newla = lines[1]
                newl1 = lines[1].split(' ')
                for terms in newl1:
                    newl2 = terms.split(' ')
                    for keys in self.odict:
                        mtag = self.odict[keys][0]
                        if mtag == '[t]':
                            for term in newl2:
                                if keys == term[1:].strip():
                                    newla = newla.replace('%'+str(keys),
                                    str(eval(self.odict[keys][2])))
                oldfile[int(lines[0])-1] = newla+"\n"

            # write edited file
            if var1 != '':
                newfile1 = os.path.basename(fpath)
                newfile1 = newfile1.split('.')
                newfile2 = '.'.join([str(newfile1[0]) +
                                var1.strip(), newfile1[1]])
                newfile = os.path.join(os.path.dirname(fpath),newfile2)
            else:
                newfile = fpath

            f = open(newfile, 'w')
            writefile = ''.join(oldfile)
            f.write(writefile)
            f.close()

            tmp = int(self.widthc-2) * '-'
            self._prt_utf((u'\u250C' + tmp + u'\u2510').rjust(self.widthc), 0)

            strend = dval[1].strip() + " | edit file "
            self._prt_utf(strend.rjust(self.widthc - 1), 0)
            self._prt_utf(" ", 0)

            # write edit table
            self._prt_utf("file: " + dval[1].strip(), 0)
            title1 = '[line #]'.center(8) + \
                     '[replacement line]'.rjust(25)
            self._prt_utf(title1, 0)
            for _i in var3:
                self._prt_utf(('  ' + _i[0].strip()).ljust(10)
                              + (_i[1].strip()), 1)
            self._prt_utf(' ', 0)

            tmp = int(self.widthc-2) * '-'
            self._prt_utf((u'\u2514' + tmp + u'\u2518').rjust(self.widthc), 0)
            self._prt_utf(" ", 0)

            link1 = "< edited file: " + str(fpath) + " >"
            self.ew.errwrite(link1, 0)

    def _prt_txt(self, txt):
        """Print pass-through text.
        ::

         arguments:
            txt (string): text that is not part of an operation

        """
        #print('txt', txt)
        # reST modification
        if txt[1].strip()[0] == '|':
            inx = txt[1].index('|')
            txt1 = txt[1].strip()[2:]
            txt1 = inx*' ' + txt1
        else:
            txt1 = txt[1].rstrip()

        if txt[1].strip()[0] != '#':
            self._prt_utf(txt1, 1)

    def _prt_blnk(self):
        """Insert blank line.

        """
        self._prt_utf(' ', 0)

    def _prt_utf(self, mentry, pp):
        """Write text to utf-8 encoded file.
        ::

         arguments:
            mentry (string): line of text
            pp (integer): flag for utf-8 and pretty print

        """
        if pp:
            mentry = pretty(mentry, use_unicode=True, num_columns=92)
        print(mentry, file=self.cfile)

    def _prt_py(self):
        """write python code to file from dictionary
        ::

         write imports, terms, equations to Python importable file
         the following libraries are imported when the file is imported:
            os
            sys
            sympy
            numpy
            numpy.linalg
            OrderedDict

        """
        pyfile1 = open(self.pyfile, 'w')
        #write import commands
        str1 = ('from __future__ import division\n'
                'from __future__ import print_function\n'
                'import os\n'
                'import sys\n'
                'from sympy import *\n'
                'from numpy import *\n'
                'import numpy.linalg as LA\n'
                'from collections import OrderedDict\n')

        str2 = ('\n""" \n'
                'this file contains Python equations from the on-c-e model \n ' +
                    self.mfile + '\n'
                '\nFor interactive analysis copy and paste the entire file\n'
                'into an Ipython Notebook cell or Komodo IDE interactive shell.\n'

                '\nFor interactive analysis in IPython in Komodo click on\n'
                'the IP[y] toolbar button. The equations will be copied to\n'
                'the sqlite history database and opened in the IPython interpreter.\n'

                '\nFor interactive analysis in the Pyzo shell copy and paste\n'
                'the Pyzo command lines above - one at a time.  Copy and paste '
                'equations from this file into the shell for interactive '
                'analysis - one at a time\n'
                '""" \n \n')

        str3a = str(os.getcwd()).replace("\\", "\\\\")
        str3 = "sys.path.append('" + str3a + "')"

        str4 = """
try:
   from unum import Unum
except:
 print('unum module not found')

try:
   from unitc import *
   print('unitc imported from directory')
except:
    try:
        from oncepy.unitc import *
        print('unitc imported from oncepy')
    except:
       print('unitc not found')
       pass
"""

        mpath1 = cfg.mpath.replace('\\','\\\\')
        pyfile1.write('\n# Pyzo command lines:\n# cd ' + mpath1 +
                      '\n# run -m onceutf ' + str(cfg.mfile)+ '\n')

        importstr = str2 + str1 + str3 + str4

        pyfile1.write(importstr + 2*"\n")

        pyfile1.write("# begin equations" + "\n")
        # write individual statements
        for _j in self.odict:
            mtype = self.odict[_j][0]
            if mtype == '[t]':
                pyfile1.write(self.odict[_j][1].strip()+'; '+ str(_j)+ '\n')
            elif mtype == '[e]':
                pyfile1.write(self.odict[_j][1].strip()+'; '+ str(_j)+ '\n')
            elif mtype == '[a]':
                    var1 = self.odict[_j][1].strip().split('=')[0]
                    if len(self.odict[_j][1].strip()):
                        pyfile1.write(self.odict[_j][1].strip()+'; '+var1+'\n')
                    var3 = self.odict[_j][3].strip().split('=')[0]
                    if len(self.odict[_j][3].strip()):
                        pyfile1.write(self.odict[_j][3].strip()+'; '+var3+'\n')
                    var4 = self.odict[_j][4].strip().split('=')[0]
                    if len(self.odict[_j][4].strip()):
                        pyfile1.write(self.odict[_j][4].strip()+'; '+var4+'\n')

        # write list of statements
        _vardef =[]
        for k1 in self.odict:               # overwrite symbolic representation
            if k1[0] != '_' or k1[0:2] == '_a':
                    try:
                        exec(self.odict[k1][1].strip())
                        if '=' in self.odict[k1][1].strip():
                            _vardef.append(self.odict[k1][1].strip())
                    except:
                        pass
                    try:
                        exec(self.odict[k1][3].strip())
                        if '=' in self.odict[k1][3].strip():
                            _vardef.append(self.odict[k1][3].strip())
                    except:
                        pass
                    try:
                        exec(self.odict[k1][4].strip())
                        if '=' in self.odict[k1][4].strip():
                            _vardef.append(self.odict[k1][4].strip())
                    except:
                        pass
        pyfile1.write('_vardef = ' + str(_vardef) + '\n')

        # write dictionary of variables
        #pdict = {}
        #for _k in self.odict:
        #    if _k[0] != '_':
        #        try:
        #            pdict[str(_k).strip()] = [self.odict[_k][1].strip(),
        #                                self.odict[_k][2].strip()]
        #        except:
        #            pass
        #    if _k == '_a':
        #        rng1 = self.odict[_k][1].split('=')
        #        rng2 = self.odict[_k][2].split('=')
        #        pdict[str(rng1[0]).strip()] = [self.odict[_k][1].strip(),
        #                          rng1[1].strip()]
        #        pdict[(rng2[0]).strip()] = [self.odict[_k][2].strip(),
        #                          rng2[1].strip()]
        #pyfile1.write(str('_md =  ') + str(pdict))
        pyfile1.close()


    def _prt_summary(self):
        """write model summary to summary file
        ::

         summarize sections, arrays, functions and equations
            sections: [[s], left string, notes]
            arrays:   [[a], state1, expr, range1, range2, ref, dec, u1, u2]
            function: [[f], function call, var, ref, eq num]
            equations:[[e], statement, expr, ref, decimals, units, prnt opt]

        """
        sumfile1 = open(self.sumfile, 'w')
        for i in self.odict:
            mtype = self.odict[i][0]
            if mtype ==   '[s]':
                sumfile1.write('section: ' + self.odict[i][1].strip()+'\n')
            elif mtype == '[a]':
                sumfile1.write('array: ' + self.odict[i][5].strip()+'\n')
            elif mtype == '[f]':
                sumfile1.write('function: ' + self.odict[i][3].strip()+'\n')
            elif mtype == '[e]':
                sumfile1.write('equation: ' + self.odict[i][3].strip()+'\n')
        sumfile1.close()

from __future__ import division
from __future__ import print_function
from collections import OrderedDict
import os
from unum import Unum
import oncemod.config as om
try:
    from unitc import *
except:
    from oncemod.calcunits import *



class ModDict(object):
    """Return an ordered dictionary of model operations.

    Arguments:
    mfile -- model file name
    mpath -- model file path

    Methods:
    fdicts()
    mdicts()

    """

    def __init__(self, mfile, mpath):
        """Return an ordered dictionary of model operations.

        Arguments:
        mfile -- model file name
        mpath -- model file path

        """
        # files
        mofile = open(mfile, 'r')
        self.mstr = mofile.readlines()
        mofile.close()
        self.cfolder = mpath

        # counters
        self.midx = self.snum = self.snumchk = self.enum = 1

        # initial values
        self.mnum = 1
        try:
            self.mnum = (mfile.split('.')[-2])
            om.modnumber = self.mnum = str(int(self.mnum))
        except:
            self.mnum = 1

        self.deci = 2
        self.snum = 0
        self.snumchk = 0
        self.enum = 0
        self.width_calc = 80

        # dictionaries and lists
        self.mdict = OrderedDict()
        self.fdict = {}
        self.mstrx = []

        # operation tags
        mlist = ['[e]', '[a]', '[s]', '[y]', '[d]', '[o]', '[t]',
                 '[:]', '[#]', '[~]']
        self.mtags = mlist

        # build model dictionary
        self.fdicts()  # format dictionary
        self.mdicts()  # model dictionary


    def fdicts(self):
        """Return format dictionary from format op tag

        Dictionary:
        fdict[refnumber] = [generated eqnumber, decimals, units]

        """
        pendf = False
        for _i in self.mstr:
            mtag = _i[0:10]
            if mtag == "[#] format":
                ilist = _i[3:].split('|')
                if len(ilist[1].strip()):
                    om.caltype = ilist[1].strip()
                if len(ilist[2].strip()):
                    self.deci = ilist[2]
                if len(ilist[3].strip()):
                    pfolder = ilist[3].strip()
                    self.projfolder = os.path.abspath(pfolder)
                if len(ilist[4].strip()):
                    self.setfile = ilist[4].strip()
                pendf = True
                continue
            if len(_i.strip()) == 0 and pendf is True:
                pendf = False
            if pendf is True:
                fnum, decs, unts, opt = _i.split('|')
                self.fdict[int(fnum)] = [decs, unts.strip(), opt.strip()]
            else:
                continue

    def mdicts(self):
        """Return model dictionary.

        Keys for equations and terms are the dependent
        variable. The key for other operations is generated by a
        line counter.

        For text the dictionary key is:
        _x + incremented number - pass-through text
        _s + incremented number - sections
        _i + incremented number - inserted text
        _y + incremented number - python code
        _o + incremented number - compare operation
        _a + incremented number - array and ranges

        For equations and terms the key is the dependent
        variable and the dictionary structure is:

        equations:[[e], statement, expr, ref, decimals, units, prnt opt]
        arrays:   [[a], range1, range2, state1, expr, ref, dec, u1, u2]
        sections: [[s], left string, right string, directives, notes]
        python:   [[y]]
        disk:     [[d]]
        compare:  [[o], check expr, limits, ref, ok]
        terms:    [[t], statement, expr, ref ]

        """

        Unum.VALUE_FORMAT = "%.2f"
        Unum.UNIT_INDENT = ""
        pend = ' '

        #return new list mstrx without non-printing lines
        self._model_clean()

        # build ordered dictionary of model - mdict
        ip = ''  # accumulator for multiline operations

        for _i in self.mstrx:
            self.midx += 1
            #print('i', i.strip())
            if len(_i.strip()) == 0:
                mtag = '[~]'  # blank
            else:
                if _i.lstrip()[:3] in self.mtags:
                    _i = _i.lstrip()
                    mtag = _i[:3]
                else:
                    mtag = '[x]'
            #print('tag ', mtag)

            # pending blocks
            pendlist = ['e', 'a', 's', 'y']
            if pend in pendlist and mtag != '[~]':
                ip += _i
                continue
            if pend in pendlist and mtag == '[~]':
                if pend ==   'e': self._tag_e(ip)
                elif pend == 'a': self._tag_a(ip)
                elif pend == 's': self._tag_s(ip)
                elif pend == 'y': self._tag_y(ip)
                else: pass
                ip = ''; pend = ''
                mkey = '_x' + str(self.midx)
                self.mdict[mkey] = ['[~]', ' ']
                continue

            # pass-through text
            if mtag == '[x]':
                mkey = '_x'+str(self.midx)
                self.mdict[mkey] = [mtag, _i]
                continue

            # select tag
            if mtag in self.mtags:
                if mtag ==   '[e]':
                    ip += _i
                    pend = 'e'
                elif mtag == '[a]':
                    ip += _i
                    pend = 'a'
                elif mtag == '[s]':
                    ip += _i
                    pend = 's'
                elif mtag == '[y]':
                    ip += _i
                    pend = 'y'
                elif mtag == '[d]': self._tag_d(_i)
                elif mtag == '[o]': self._tag_o(_i)
                elif mtag == '[t]': self._tag_t(_i)
                elif mtag == '[~]':
                    mkey = '_x' + str(self.midx)
                    self.mdict[mkey] = ['[~]', ' ']
                else:
                    mkey = '_x' + str(self.midx)
                    self.mdict[mkey] = ['[x]', _i]
        #for _i in self.mdict: print(self.mdict[i])

    def _tag_e(self, ip):
        """add [e] to mdict.

        Arguments:
        ip: a model line or block

        Dictionary:
        equations:[[e], statement, expr, ref, decimals, units, prnt opt]

        """

        # reset equation number at new section
        self.enum += 1
        if self.snum > self.snumchk:
            self.enum = 1
            self.snumchk = self.snum
        ivect = ip.split('\n')
        fnum, ref = ivect[0][3:].split("|")
        decs, unts, opt = self.fdict[int(fnum)]
        enumb = ' [' + self.mnum + '.' + str(self.snum) + '.'+ \
                str(self.enum) + ']'
        ref = ref.strip() + enumb

        # set dictionary values
        state = ''
        for j in ivect[1:]:
            state = state + j.strip()
        expr = state.split("=")[1].strip()
        var1 = state.split("=")[0].strip()
        self.mdict[var1] = ['[e]', state, expr, ref, decs, unts, opt]

    def _tag_a(self, ip):
        """ add [a] to mdict.

        Arguments:
        ip: a model line or block

        Dictionary:
        arrays:   [[a], range1, range2, statement, expr,
        ref, decimals, unit1, unit2]

        """

        # reset equation number at new section
        self.enum += 1
        if self.snum > self.snumchk:
            self.enum = 1
            self.snumchk = self.snum
        ivect = ip.strip().split('\n')
        fnum, ref = ivect[0].strip()[3:].split("|")
        decs, unts, opt = self.fdict[int(fnum)]
        enumb = ' [' + self.mnum + '.' + str(self.snum) + '.' + \
                str(self.enum) + '] '

        ref = '  ' + ref.strip().ljust(self.width_calc-len(enumb)-2) + \
              enumb

        self.enum += 1
        # set dictionary values
        rng1 = rng2 = state = expr = ''
        var2 = '_a' + str(self.midx)
        arrayblock = ivect[1:]
        #print(arrayblock)
        if len(arrayblock) == 1:
            state = expr = arrayblock[0]

        elif len(arrayblock) == 2:
            rng1 = arrayblock[0]
            state = arrayblock[1]
            expr = state.split("=")[1].strip()

        elif len(arrayblock) == 3:
            rng1 = arrayblock[0]
            rng2 = arrayblock[1]
            state = arrayblock[2]
            expr = state.split("=")[1].strip()

        self.mdict[var2] = ['[a]', rng1, rng2, state, expr, ref,
                            decs, unts, opt]
        #print(state)

    def _tag_s(self, ip):
        """add [s] to mdict.

        Argument:
        ip: a model line or block

        Dictionary:
        sections: [[s], left string, right string, directives, notes]

        """

        ivect = ip.split('\n')
        #print(ivect)
        sleft, sright, sdata = ivect[0][3:].split('|')
        sdata = sdata.strip()
        if len(sdata) == 0:
            sdata = '-'
        state = ivect[1:]
        self.snum += 1
        sleft = '[' + self.mnum + '.' + str(self.snum) + '] ' + \
                    sleft.strip()
        mkey = '_s' + str(self.midx)
        self.mdict[mkey] = ['[s]', sleft, sright, sdata, state]

    def _tag_y(self, ip):
        """add [y] to mdict"""
        pass

    def _tag_d(self, i):
        """add [d] to mdict"""
        pass

    def _tag_o(self, _i):
        """add [o] to mdict

        Argument:
        i: model input line

        Dictionary:
        compare:  [[o], check expr, limits, ref, ok]

        """

        ivect = _i
        ref, check, limits, ok = ivect[3:].strip().split("|")
        self.enum += 1
        if self.snum > self.snumchk:
            self.enum = 1
            self.snumchk = self.snum

        enumb = ' [' + self.mnum + '.' + str(self.snum) + '.'+ \
                str(self.enum) + ']'
        ref = ref.strip() + enumb
        mkey = '_o'+str(self.midx)
        self.mdict[mkey] = ['[o]', check, limits, ref, ok]

    def _tag_t(self, i):
        """add [t] to mdict

        Argument:
        i: a model line

        Dictionary:
        terms: [[t], statement, expr, ref ]

        """

        ivect = i
        state, ref = ivect[3:].split("|")
        var = state.split("=")[0].strip()
        expr = state.split("=")[1].strip()
        self.mdict[var] = ['[t]', state, expr, ref]

    def _model_clean(self):
        """Remove non-printing lines from model file.

        Shift indented tags to first column.

        """

        pend = False
        for _j in self.mstr:
            mtag = _j.strip()[0:3]
            if mtag == '[#]':
                if str(_j[:10]) == '[#] format': pend = True
                continue
            if pend and len(_j.strip()) == 0:
                pend = False
                continue
            if pend: continue
            self.mstrx.append(_j)
        #print('mstrx',self.mstrx)


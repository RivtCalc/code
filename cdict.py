from __future__ import division
from __future__ import print_function
from collections import OrderedDict
import os
from numpy import *
from oncepy import ccheck
import oncepy.oconfig as cfg


class ModDicts(object):
    """Return dictionaries of model operations and formats

    Attributes:
        build_fdict(str list): format dictionary
        build_mdict(str list): ordered dictionary of operations

    """
    def __init__(self):
        """Assemble dictionaries from models and comodels

        """

        # execution log
        self.ew = ccheck.ModCheck()

        # list of all model paths and model contents
        #print(os.path.join(mpath, mfile))
        mpathfile = os.path.join(cfg.mpath, cfg.mfile)
        mofile = open(mpathfile, 'r')
        self.mstr = mofile.readlines()
        mofile.close()

        # read format defaults from main file
        # default formats are also stored in dictionary
        self.widthc = 90
        for _i in self.mstr:
            mtag = _i[0:10]
            if mtag == "[#] format":
                ilist = _i[3:].split('|')
                caltype = ilist[2].strip()
                cfg.caltype = caltype
                dec1 = ilist[1].strip
                cfg.defaultdec = dec1

        # list of model and comodel files with all lines
        self.mstrlist = []
        mainmod1 = []
        for lines in self.mstr:
            parseline = lines[3:].split('|')
            if lines[0:3] == '[d]' and parseline[1].strip() == 'i':
                link1 = "< inserted comodel from: " + \
                        parseline[0].strip() + " >"
                self.ew.ewrite2(link1)
                # write main model segments to list and clear
                if len(mainmod1) > 0:
                    moddata = []
                    moddata.append(mpathfile)
                    moddata.append(mainmod1)
                    self.mstrlist.append(moddata)
                    mainmod1 = []

                # write any comodels
                moddata = []
                os.chdir(os.pardir)
                mofileimp = os.path.abspath(parseline[0].strip())
                f1 = open(mofileimp, 'r')
                moreadimp = f1.readlines()
                moddata.append(mofileimp)
                moddata.append(moreadimp)
                self.mstrlist.append(moddata)
                f1.close()
                os.chdir(cfg.mpath)
                continue
            mainmod1.append(lines)

        # write remaining main model segments
        moddata = []
        moddata.append(mpathfile)
        moddata.append(mainmod1)
        self.mstrlist.append(moddata)

        # initialize section and equation labels
        self.midx = 1
        self.snum = self.snumchk = self.enum = 0
        self.dec1 = 2

        try:
            self.mnum = (self.mfile.split('.')[0])
            self.modelnum = str(int(self.mnum))
        except:
            self.mnum = '0001'

        # dictionaries and lists
        self.mdict = OrderedDict()
        self.fdict = {}
        self.mstrx = []

        # operation tags
        mlist = ['[d]', '[o]', '[t]',
                 '[c]', '[a]', '[f]', '[e]', '[s]',
                 '[:]', '[#]', '[~]']
        self.mtags = mlist

        # build dicts
        dflag = 0
        #print(self.mstrlist)
        for curmod in self.mstrlist:
            dflag += 1
            self.build_fdict(curmod)  # format dictionary
        self.ew.ewrite2("< built format dictionary " +
                        str(dflag) + " >\n")

        for curmod in self.mstrlist:
            self.mfile1 = os.path.split(curmod[0])[-1].strip()
            self.build_mdict(curmod)  # model dictionary
        self.ew.ewrite2("< built model dictionary > \n")

    def build_fdict(self, curmod):
        """Return format dictionary from format op tag

        Dictionary:
        fdict[refnumber] = [decimals, units, units]

        """
        # set reference values
        pendf = False
        for _i in curmod[1]:
            mtag = _i[0:10]
            if mtag == "[#] format":
                pendf = True
                comnt, formt, calctype = _i.split('|')
                self.fdict['default'] = [formt.strip(), calctype.strip()]
                continue
            if pendf:
                if len(_i.strip()) == 0:
                    break
                else:
                    fnum, dec2, unts, opt = _i.split('|')
                    self.fdict[int(fnum)] = [dec2.strip(),
                                unts.strip(), opt.strip()]

    def build_mdict(self, curmod):
        """Return model dictionary.

        Keys for equations and terms are the dependent
        variable. Keys for other operations are generated by a
        line counter.

        For non-equation entries the dictionary key is:
        _x + incremented number - pass-through text
        _o + incremented number - symbolic representation
        _s + incremented number - sections
        _i + incremented number - inserted text
        _y + incremented number - python code
        _c + incremented number - check operation
        _a + incremented number - array and ranges
        _m + incremented number - current model directory
        _d + incremented number - disk operation
        _f + incremented number - function

        Operation dictionary structure:

        single line inputs:
        disk:     [[d], filename, parameter, var]
        symbolic: [[o], expr]
        terms:    [[t], statement, expr, ref ]

        multiline inputs
        check:    [[c], check expr, limits, ref, ok]
        arrays:   [[a], state1, expr, range1, range2, ref, dec, u1, u2]
        function: [[f], function name, file name]
        equations:[[e], statement, expr, ref, decimals, units, prnt opt]
        sections: [[s], left string, notes]

        """
        # populate list mstrx with lines that generate printed text
        self.mstr = curmod[1]
        #print(curmod[0])
        self.mstrx = []
        self._model_clean()

        # build ordered dictionary mdict of models
        ip = ''  # accumulator for multiline operations
        pend = ' '

        # write model directory
        self.midx += 1
        mkey = '_m'+str(self.midx)
        self.mdict[mkey] = [curmod[0].strip()]

        for _i in self.mstrx:
            if _i.strip() == '[#] stop':
                break
            self.midx += 1
            #print('i', _i.strip())
            if len(_i.strip()) == 0:
                mtag = '[~]'  # blank line
            else:
                if _i.lstrip()[:3] in self.mtags:
                    _i = _i.lstrip()
                    mtag = _i[:3]
                else:
                    mtag = '[x]'
            #print('tag ', mtag)

            # pending multiline blocks
            pendlist = ['d', 'o', 'c', 'a', 'f', 'e', 's']
            if pend in pendlist and mtag != '[~]':
                ip += _i
                continue
            if pend in pendlist and mtag == '[~]':
                if pend ==   'd': self._tag_d(ip)
                elif pend == 'o': self._tag_o(ip)
                elif pend == 'c': self._tag_c(ip)
                elif pend == 'a': self._tag_a(ip)
                elif pend == 'f': self._tag_f(ip)
                elif pend == 'e': self._tag_e(ip)
                elif pend == 's': self._tag_s(ip)
                else:
                    pass
                ip = ''
                pend = ''
                mkey = '_x' + str(self.midx)
                self.mdict[mkey] = ['[~]', ' ']
                continue

            # pass-through text
            if mtag == '[x]':
                mkey = '_x'+str(self.midx)
                self.mdict[mkey] = [mtag, _i]
                continue

            # select tag
            if mtag in self.mtags:
                if mtag == '[d]':
                    if _i.split('|')[1].strip() == 'e':
                        ip += _i
                        pend = 'd'
                    else:
                        self._tag_d(_i)
                elif mtag == '[o]':
                    ip += _i
                    pend = 'o'
                elif mtag == '[t]':
                    self._tag_t(_i)
                elif mtag == '[c]':
                    ip += _i
                    pend = 'c'
                elif mtag == '[a]':
                    ip += _i
                    pend = 'a'
                elif mtag == '[f]':
                    ip += _i
                    pend = 'f'
                elif mtag == '[e]':
                    ip += _i
                    pend = 'e'
                elif mtag == '[s]':
                    ip += _i
                    pend = 's'
                elif mtag == '[~]':
                    mkey = '_x' + str(self.midx)
                    self.mdict[mkey] = ['[~]', ' ']
                else:
                    mkey = '_x' + str(self.midx)
                    self.mdict[mkey] = ['[x]', _i]

        #for _i in self.mdict: print(self.mdict[i])

    def _tag_d(self, mstrng):
        """add [d] to mdict

        Arguments:
        ip: a model line or block

        Dictionary Value:
        equation:[[d], file path, parameter, var1, var2, var3, file]

        parameters:
        s: run a python script
        t: add text file contents to output
            No operations are processed.
        o: run an external operating system command.
        w: write values of variable to file. w+ appends to file.
        f: insert jpg, png etc, figures into calc
        i: insert and process external model file.
            Integrate sections and equation numbering.
        r: read file data into variable - processed when tagged
        e: edit file. Store edits in var3. (multiline)
        """

        _prt_log = self.ew.ewrite2

        # check if special case of multiline 'e' option
        try:
            ivect = mstrng.split('\n')
            ivect1 = ivect[0].strip()[3:].split('|')
        except:
            ivect = mstrng.strip()
            ivect1 = ivect[3:].split('|')

        #print('ivect', ivect)
        fpath = ivect1[0].strip()
        param = ivect1[1].strip()
        var1 = ivect1[2].strip()
        var2 = ivect1[3].strip()
        var3 = ivect1[4]   # also used for edit lines and file data

        # insert lines from text file
        if param == 't':
            f1 = open(fpath, 'r')
            txstrng = f1.readlines()
            f1.close()
            if var1.strip() != '':
                instxt = eval('txstrng[' + var1.strip() + ']')
                instxt = ''.join(instxt)
            else:
                instxt = ''.join(txstrng)
            mkey = '_x'+str(self.midx)
            self.mdict[mkey] = ['[x]', instxt]

            link1 = "< text inserted from file: " + str(fpath) + " >"
            _prt_log(link1)
            _prt_log('')

        # read data
        elif param == 'r':

            # add to dictionary
            mkey = '_r' + str(self.midx)
            self.mdict[mkey] = ['[r]', fpath, param, var1, var2,
                                var3, '['+self.mfile1+']']

            link1 = "< data file:" + fpath + " = " + \
                    var1 + ">"
            _prt_log(link1)

        # edit file - store edit ines in var 3
        elif param == 'e':
            mkey = '_e' + str(self.midx)
            var3 = ivect[1:]
            self.mdict[mkey] = ['[d]', fpath, param, var1, var2,
                                var3, '['+self.mfile1+']']
        else:
            mkey = '_d' + str(self.midx)
            self.mdict[mkey] = ['[d]', fpath, param, var1, var2,
                                var3.strip(), '['+self.mfile1+']']

    def _tag_o(self, expr):
        """add [o] to mdict

        Argument:
            expr (str): a model line

        Dictionary:
            symbolic: [[o], expr ]

        """

        mkey = '_o' + str(self.midx)
        self.mdict[mkey] = ['[o]', expr[3:].strip()]


    def _tag_t(self, line):
        """add [t] to mdict

        Argument:
            i: a model line

        Dictionary:
            terms: [[t], statement, expr, ref ]

        """
        ivect = line
        ref, state = ivect[3:].split("|")
        var = state.split("=")[0].strip()
        expr = state.split("=")[1].strip()
        self.mdict[var] = ['[t]', state.strip(), expr, ref,
                           '['+self.mfile1.split('.')[0]+']']

    def _tag_c(self, line):
        """add [c] to mdict

        Argument:
        i: model input line

        Dictionary:
        check:  [[c], check expr, op, limit, ref, dec, ok]

        """
        ivect = line.split('\n')
        dec, ref, ok = ivect[0].strip()[3:].split('|')
        check, op, limits = ivect[1].strip().split('|')
        self.enum += 1
        if self.snum > self.snumchk:
            self.enum = 1
            self.snumchk = self.snum

        enumb = ' [' + self.mnum + '.' + str(self.snum) + '.' + \
                str(self.enum) + ']'
        ref = ref.strip() + enumb
        mkey = '_c'+str(self.midx)
        self.mdict[mkey] = ['[c]', check, op, limits, ref, dec, ok]

    def _tag_a(self, line):
        """ add [a] to mdict.

        Arguments:
        ip: a model line or block

        Dictionary:
        arrays:   [[a], statement, expr, range1, range2,
        ref, decimals, unit1, unit2, model]

        """
        # reset equation number at new section
        self.enum += 1
        if self.snum > self.snumchk:
            self.enum = 1
            self.snumchk = self.snum
        ivect = line.strip().split('\n')
        fnum, ref = ivect[0].strip()[3:].split("|")
        decs, unts, opt = self.fdict[int(fnum)]
        if unts == '':
            unts = self.fdict['default'][1]
        enumb = ' [' + str(self.mnum) + '.' + str(self.snum) + '.' + \
                str(self.enum) + '] '

        ref = '  ' + ref.strip().ljust(self.widthc-len(enumb)-2) + \
              enumb

        # set dictionary values
        rng1 = rng2 = state = expr = ''
        mkey = '_a' + str(self.midx)
        arrayblock = ivect[1:]
        if len(arrayblock) == 1:
            state = expr = arrayblock[0]

        elif len(arrayblock) == 2:
            rng1 = arrayblock[0]
            state = arrayblock[1]
            expr = state.split("=")[1].strip()

        elif len(arrayblock) == 3:
            rng1 = arrayblock[0]
            rng2 = arrayblock[1]
            state = arrayblock[2]
            expr = state.split("=")[1].strip()

        self.mdict[mkey] = ['[a]', state, expr, rng1, rng2, ref,
                            decs, unts, opt,
                            '['+self.mfile1.split('.')[0]+']']
        #print(state)

    def _tag_f(self, line):
        """add [f] to mdict

        Arguments:
        ip: a model line or block

        Dictionary Value:
        function:[[f], function call, var, ref

        """
        ivect = line.split('\n')
        fname = ivect[1]
        var2 = ivect[0].split('|')[0][3:].strip()
        ref = ivect[0].split('|')[1].strip()

        # set dictionary values
        mkey = '_f' + str(self.midx)
        self.mdict[mkey] = ['[f]', fname, var2, ref,
                            '['+self.mfile1.split('.')[0]+']']

    def _tag_e(self, line):
        """add [e] to mdict.

        Arguments:
        ip: a model line or block

        Dictionary Value:
        equation:[[e], statement, expr, ref, decimals, units, prnt opt]

        """
        # reset equation number at new section
        self.enum += 1
        if self.snum > self.snumchk:
            self.enum = 1
            self.snumchk = self.snum
        ivect = line.split('\n')
        #print(ivect)
        fnum, ref = ivect[0][3:].split("|")
        decs, unts, opt = self.fdict[int(fnum)]
        if unts == '':
            unts = self.fdict['default'][1]
        enumb = ' [' + self.mnum + '.' + str(self.snum) + '.'+ \
                str(self.enum) + ']'
        ref = ref.strip() + enumb

        # set dictionary values
        state = ''
        for j in ivect[1:]:
            state = state + j.strip()
        expr = state.split("=")[1].strip()
        var1 = state.split("=")[0].strip()
        self.mdict[var1] = ['[e]', state, expr, ref, decs, unts, opt,
                            '['+self.mfile1.split('.')[0]+']']

    def _tag_s(self, line):
        """add [s] to mdict.

        Argument:
        ip: a model line or block

        Dictionary:
        sections: [[s], left string, notes]

        """
        ivect = line.split('\n')
        #print(ivect)
        sleft = ivect[0][3:].strip()
        state = ivect[1:]
        self.snum += 1
        sleft = '[' + self.mnum + '.' + str(self.snum) + '] ' + sleft
        mkey = '_s' + str(self.midx)
        self.mdict[mkey] = ['[s]', sleft, state,
                            '['+self.mfile1.split('.')[0]+']']

    def _model_clean(self):
        """Remove non-printing lines from model file.

        Shift indented tags to first column.

        """
        pend = False
        for _j in self.mstr:
            mtag = _j.strip()[0:3]
            if str(_j[:8]) == '[#] stop':
                self.mstrx.append(_j)
                continue
            if mtag == '[#]':
                if str(_j[:10]) == '[#] format':
                    pend = True
                continue
            if pend and len(_j.strip()) == 0:
                pend = False
                continue
            if pend:
                continue
            self.mstrx.append(_j)
        #print('mstrx',self.mstrx)


